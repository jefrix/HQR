<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HQR Simplified Visualizations</title>
    <link rel="stylesheet" href="visualization.css">
    <!-- Required libraries for React visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/17.0.2/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.2/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.1.9/Recharts.js"></script>

    <!-- Correct paths for root directory -->
<script src="visualization.js"></script>
<script src="hqr-visualization.js"></script>
    
    <!-- Custom stylesheets -->
    <link rel="stylesheet" href="visualization.css">
    
    <!-- Base styles that should remain in HTML -->
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: La0;
            padding: 0;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        
        .header {
            padding: 20px;
            background-color: #0d1117;
            border-bottom: 1px solid #30363d;
        }
        
        .back-link {
            color: #58a6ff;
            text-decoration: none;
            display: inline-block;
            margin-bottom: 10px;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .intro {
            margin-bottom: 30px;
            line-height: 1.6;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            border-top: 1px solid #30363d;
            color: #8b949e;
        }
        
        /* Pre-animation styles for transitions */
        .visualization-section {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        
        .visualization-section.loaded {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Loading indicator */
        .loading-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #58a6ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Error state styling */
        .error-state {
            background-color: #2d0b0b;
            border: 1px solid #f85149;
            color: #f85149;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
    </style>
</head>
<body class="dark-theme">
    <div class="header">
        <a href="index.html" class="back-link">← Back to Main Page</a>
        <h1>HQR Mathematical Visualizations</h1>
    </div>
    
    <div class="container">
        <div class="intro">
            <p>These visualizations demonstrate the key mathematical components of Holonomic Quantum Reality (HQR) theory. Toggle between 4D and 11D representations to see how higher dimensions introduce additional complexity. Hover over elements to see detailed values and explore the relationships between different components of the theory.</p>
        </div>
        
        <div id="error-message" class="error-message">
            Unable to load interactive visualizations. Please ensure JavaScript is enabled in your browser.
        </div>
        
        <div class="visualization-section" data-animation-delay="100">
            <h2>Wave Function & Hidden Order</h2>
            
            <div class="controls">
                <div>
                    <label for="dimension-select">Choose Dimension: </label>
                    <select id="dimension-select" onchange="updateDimension(this.value)">
                        <option value="4D">4D Reality</option>
                        <option value="11D">11D M-Theory</option>
                    </select>
                </div>
                <div id="dimension-display">Currently viewing: 4D Reality</div>
            </div>
            
            <div class="visualization-container">
                <div class="visualization-card">
                    <h3>Bohmian Mechanics Wave Function (Ψ = Re<sup>iS/ℏ</sup>)</h3>
                    <p>Visualizing components of the wave function and velocity field from guiding equation: dx/dt = ∇S/m</p>
                    <div class="chart-container">
                        <canvas id="wave-function-canvas"></canvas>
                    </div>
                </div>
                
                <div class="visualization-card">
                    <h3>Hidden Order Correlation</h3>
                    <p>Visualizing correlation function ⟨O(x)O(y)⟩ as a projection from higher dimensions</p>
                    <div class="chart-container">
                        <canvas id="correlation-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="visualization-section" data-animation-delay="200">
            <h2>Holographic Principle: AdS/CFT Correspondence</h2>
            <p>Visualizing the relationship between bulk AdS space and boundary CFT: Z<sub>CFT</sub> = ∫Dϕe<sup>-S<sub>bulk</sub>[ϕ]</sup></p>
            
            <div class="chart-container">
                <canvas id="holographic-canvas"></canvas>
            </div>
        </div>
        
        <div class="visualization-section" data-animation-delay="300">
            <h2>Key Equations of HQR</h2>
            
            <div class="equation-container">
                <div class="equation-card">
                    <div class="equation-title">M-Theory Metric</div>
                    <div class="equation">ds² = g<sub>μν</sub>dx<sup>μ</sup>dx<sup>ν</sup>, μ,ν = 0,1,...,10</div>
                    <div class="equation-description">Describes spacetime in 11 dimensions, where the extra dimensions are compactified at scales too small to observe directly.</div>
                </div>
                
                <div class="equation-card">
                    <div class="equation-title">Bohmian Mechanics Guiding Equation</div>
                    <div class="equation">dx/dt = ∇S/m</div>
                    <div class="equation">Where Ψ = Re<sup>iS/ℏ</sup></div>
                    <div class="equation-description">Determines particle trajectories from the wave function, providing a deterministic interpretation of quantum mechanics.</div>
                </div>
                
                <div class="equation-card">
                    <div class="equation-title">Hidden Order Correlation</div>
                    <div class="equation">⟨O(x)O(y)⟩</div>
                    <div class="equation-description">Measures subtle, long-range quantum correlations in many-body systems, potentially arising from higher-dimensional dynamics.</div>
                </div>
                
                <div class="equation-card">
                    <div class="equation-title">AdS/CFT Correspondence</div>
                    <div class="equation">Z<sub>CFT</sub> = ∫Dϕe<sup>-S<sub>bulk</sub>[ϕ]</sup></div>
                    <div class="equation-description">Links boundary conformal field theory to bulk anti-de Sitter gravity, supporting the holographic principle in HQR.</div>
                </div>
            </div>
        </div>
        
        <!-- React-based Hidden Order Parameter Visualization -->
        <div class="visualization-section" data-animation-delay="400">
            <h2>Hidden Order Parameter Analysis</h2>
            <p>Interactive visualization of hidden order parameters, entropy components, and phase transitions in quantum systems.</p>
            
            <!-- React component will be mounted here -->
            <div id="hidden-order-visualization-root">
                <div class="loading-spinner">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
        
        <!-- New advanced visualization section for HQR -->
        <div class="visualization-section" data-animation-delay="500">
            <h2>Advanced HQR Dynamic Visualizations</h2>
            <p>Interactive physics models demonstrating the core principles of Holonomic Quantum Reality theory with real-time parameter adjustments.</p>
            
            <!-- HQR React component will be mounted here -->
            <div id="hqr-visualization-root">
                <div class="loading-spinner">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        © 2025 HQR Team | <a href="index.html" style="color: #58a6ff;">Return to Main Page</a>
    </footer>
    
    <!-- Load regular canvas-based visualizations -->
    <script>
        // Simple JavaScript to handle dimension toggling and basic canvas drawing
        let currentDimension = '4D';
        
        // Update dimension display and redraw visualizations
        function updateDimension(dimension) {
            currentDimension = dimension;
            document.getElementById('dimension-display').textContent = 'Currently viewing: ' + dimension;
            
            // Redraw all visualizations with the new dimension
            drawWaveFunction();
            drawCorrelation();
            drawHolographic();
        }
        
        // Draw wave function visualization
        function drawWaveFunction() {
            const canvas = document.getElementById('wave-function-canvas');
            if (!canvas) {
                console.error('Canvas element wave-function-canvas not found');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get 2D context for wave-function-canvas');
                return;
            }
            
            // Set canvas dimensions correctly - this is crucial
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 0.5;
            
            // Vertical grid lines
            for (let x = 0; x <= canvas.width; x += 30) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let y = 0; y <= canvas.height; y += 30) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Center axes
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.strokeStyle = '#8b949e';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            
            // Draw curves
            const complexity = currentDimension === '4D' ? 1 : 2;
            
            // Real part curve
            ctx.strokeStyle = '#8884d8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let x = 0; x < canvas.width; x++) {
                // Map canvas x to wave function domain [-10, 10]
                const xValue = (x / canvas.width) * 20 - 10;
                
                // Calculate y from real part of wave function
                const amplitude = Math.exp(-xValue*xValue / 4);
                const phase = xValue*xValue / 2 * complexity;
                const realPart = amplitude * Math.cos(phase);
                
                // Map to canvas coordinates
                const y = centerY - realPart * (canvas.height * 0.4);
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Imaginary part curve
            ctx.strokeStyle = '#82ca9d';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let x = 0; x < canvas.width; x++) {
                const xValue = (x / canvas.width) * 20 - 10;
                const amplitude = Math.exp(-xValue*xValue / 4);
                const phase = xValue*xValue / 2 * complexity;
                const imagPart = amplitude * Math.sin(phase);
                const y = centerY - imagPart * (canvas.height * 0.4);
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Hidden order correlation (dashed line)
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            
            for (let x = 0; x < canvas.width; x++) {
                const xValue = (x / canvas.width) * 20 - 10;
                const amplitude = Math.exp(-xValue*xValue / 4);
                const hiddenOrder = amplitude * Math.cos(complexity * xValue / 2) * Math.exp(-Math.abs(xValue) / 5);
                const y = centerY - hiddenOrder * (canvas.height * 0.4);
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Reset line dash
            ctx.setLineDash([]);
            
            // Legend
            const legendItems = [
                { color: '#8884d8', label: 'Real Part (Re[Ψ])' },
                { color: '#82ca9d', label: 'Imaginary Part (Im[Ψ])' },
                { color: '#ff0000', label: 'Hidden Order ⟨O(x)O(0)⟩' }
            ];
            
            ctx.font = '12px Arial';
            let legendY = 20;
            
            legendItems.forEach(item => {
                // Color box
                ctx.fillStyle = item.color;
                ctx.fillRect(10, legendY, 15, 15);
                
                // Label
                ctx.fillStyle = '#e0e0e0';
                ctx.fillText(item.label, 35, legendY + 12);
                
                legendY += 25;
            });
        }
        
        // Draw correlation visualization
        function drawCorrelation() {
            const canvas = document.getElementById('correlation-canvas');
            if (!canvas) {
                console.error('Canvas element correlation-canvas not found');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get 2D context for correlation-canvas');
                return;
            }
            
            // Set canvas dimensions correctly
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 0.5;
            
            // Vertical grid lines
            for (let x = 0; x <= canvas.width; x += 30) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let y = 0; y <= canvas.height; y += 30) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Center axes
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.strokeStyle = '#8b949e';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            
            // Draw correlation points
            const complexity = currentDimension === '4D' ? 1 : 2;
            const resolution = 20;
            
            for (let i = 0; i <= resolution; i++) {
                const u = (i / resolution) * Math.PI * 2;
                for (let j = 0; j <= resolution; j++) {
                    const v = (j / resolution) * Math.PI;
                    
                    // Parametric equations for projection
                    let x, y;
                    
                    if (currentDimension === '4D') {
                        x = Math.sin(u) * Math.sin(v);
                        y = Math.sin(u) * Math.cos(v);
                    } else {
                        x = Math.sin(u) * Math.sin(v) + 0.3 * Math.sin(3 * u);
                        y = Math.sin(u) * Math.cos(v) + 0.3 * Math.cos(2 * v);
                    }
                    
                    // Scale to canvas
                    x = centerX + x * (canvas.width * 0.4);
                    y = centerY - y * (canvas.height * 0.4);
                    
                    // Correlation intensity determines color
                    const correlation = Math.pow(Math.cos(complexity * u) * Math.sin(complexity * v), 2);
                    
                    // Blue color with varying intensity
                    const blue = Math.floor(150 + correlation * 105);
                    ctx.fillStyle = `rgb(50, 50, ${blue})`;
                    
                    // Draw point
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Legend
            ctx.font = '12px Arial';
            
            // Color gradient legend
            const gradientWidth = 150;
            const gradientHeight = 15;
            const gradientX = 10;
            const gradientY = 20;
            
            for (let i = 0; i < gradientWidth; i++) {
                const ratio = i / gradientWidth;
                const blue = Math.floor(150 + ratio * 105);
                ctx.fillStyle = `rgb(50, 50, ${blue})`;
                ctx.fillRect(gradientX + i, gradientY, 1, gradientHeight);
            }
            
            // Legend labels
            ctx.fillStyle = '#e0e0e0';
            ctx.fillText('Weak', gradientX, gradientY + gradientHeight + 15);
            ctx.fillText('Strong', gradientX + gradientWidth - 50, gradientY + gradientHeight + 15);
        }
        
        // Draw holographic visualization
        function drawHolographic() {
            const canvas = document.getElementById('holographic-canvas');
            if (!canvas) {
                console.error('Canvas element holographic-canvas not found');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get 2D context for holographic-canvas');
                return;
            }
            
            // Set canvas dimensions correctly
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Center and radius
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.4;
            
            // Draw boundary circle (CFT)
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw concentric circles (AdS bulk)
            const circles = [0.8, 0.6, 0.4, 0.2];
            
            circles.forEach((scale, idx) => {
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 1 + (1-scale) * 2;
                ctx.globalAlpha = 0.4 + ((1-scale) * 0.6);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * scale, 0, Math.PI * 2);
                ctx.stroke();
            });
            
            // Reset opacity
            ctx.globalAlpha = 1;
            
            // Draw radial lines
            const angles = [0, 45, 90, 135, 180, 225, 270, 315];
            
            angles.forEach(angle => {
                const radian = angle * Math.PI / 180;
                const x = centerX + Math.cos(radian) * radius;
                const y = centerY + Math.sin(radian) * radius;
                
                ctx.strokeStyle = '#93c5fd';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x, y);
                ctx.stroke();
            });
            
            // Reset opacity
            ctx.globalAlpha = 1;
            
            // Draw central point (deep bulk)
            ctx.fillStyle = '#1d4ed8';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw MERA tensor network for 11D
            if (currentDimension === '11D') {
                drawTensorNetwork(ctx, centerX, centerY, radius);
            }
            
            // Legend
            const legendItems = [
                { color: '#ef4444', label: 'CFT Boundary (Our 4D Reality)', type: 'line' },
                { color: '#1d4ed8', label: 'AdS Bulk (Higher Dimensions)', type: 'circle' }
            ];
            
            if (currentDimension === '11D') {
                legendItems.push({ color: '#93c5fd', label: 'MERA Tensor Network', type: 'line' });
            }
            
            ctx.font = '12px Arial';
            let legendY = 20;
            
            legendItems.forEach(item => {
                if (item.type === 'line') {
                    // Line
                    ctx.strokeStyle = item.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(10, legendY + 7);
                    ctx.lineTo(25, legendY + 7);
                    ctx.stroke();
                } else {
                    // Circle
                    ctx.fillStyle = item.color;
                    ctx.beginPath();
                    ctx.arc(17, legendY + 7, 7, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Label
                ctx.fillStyle = '#e0e0e0';
                ctx.fillText(item.label, 35, legendY + 12);
                
                legendY += 25;
            });
        }
        
        // Helper function to draw tensor network
        function drawTensorNetwork(ctx, centerX, centerY, radius) {
            ctx.globalAlpha = 0.4;
            
            // Define levels of the network
            const levels = [0, 1, 2, 3];
            
            // Draw nodes at each level
            levels.forEach(level => {
                const levelRadius = (level === 0) ? 10 : radius * (0.2 + level * 0.2);
                const nodesAtLevel = 4 + level * 2;
                
                for (let i = 0; i < nodesAtLevel; i++) {
                    const angle = (i / nodesAtLevel) * Math.PI * 2;
                    const x = centerX + levelRadius * Math.cos(angle);
                    const y = centerY + levelRadius * Math.sin(angle);
                    
                    // Node color based on level
                    if (level === 0) {
                        ctx.fillStyle = '#1d4ed8';
                    } else if (level === 3) {
                        ctx.fillStyle = '#ef4444';
                    } else {
                        ctx.fillStyle = '#3b82f6';
                    }
                    
                    // Draw node
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw connections between adjacent levels
            for (let level = 0; level < 3; level++) {
                const innerRadius = (level === 0) ? 10 : radius * (0.2 + level * 0.2);
                const outerRadius = radius * (0.2 + (level + 1) * 0.2);
                const innerNodes = 4 + level * 2;
                const outerNodes = 4 + (level + 1) * 2;
                
                for (let i = 0; i < innerNodes; i++) {
                    const innerAngle = (i / innerNodes) * Math.PI * 2;
                    const x1 = centerX + innerRadius * Math.cos(innerAngle);
                    const y1 = centerY + innerRadius * Math.sin(innerAngle);
                    
                    // Connect each inner node to two outer nodes
                    for (let j of [i*2, i*2+1]) {
                        j = j % outerNodes; // Ensure we don't go out of bounds
                        const outerAngle = (j / outerNodes) * Math.PI * 2;
                        const x2 = centerX + outerRadius * Math.cos(outerAngle);
                        const y2 = centerY + outerRadius * Math.sin(outerAngle);
                        
                        // Connection color
                        ctx.strokeStyle = (level === 2) ? '#fca5a5' : '#93c5fd';
                        ctx.lineWidth = 1;
                        
                        // Draw connection
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
            }
            
            // Reset opacity
            ctx.globalAlpha = 1;
        }
        
        // Initialize visualizations
        function initVisualizations() {
            try {
                console.log("Initializing canvas visualizations...");
                
                // Check if canvas elements exist
                const waveFunctionCanvas = document.getElementById('wave-function-canvas');
                const correlationCanvas = document.getElementById('correlation-canvas');
                const holographicCanvas = document.getElementById('holographic-canvas');
                
                if (!waveFunctionCanvas) console.error("wave-function-canvas not found");
                if (!correlationCanvas) console.error("correlation-canvas not found");
                if (!holographicCanvas) console.error("holographic-canvas not found");
                
                // Force a minimum size for the chart containers
                document.querySelectorAll('.chart-container').forEach(container => {
                    if (container.clientHeight < 300) {
                        container.style.height = "300px";
                    }
                });
                
                // Now draw the visualizations
                drawWaveFunction();
                drawCorrelation();
                drawHolographic();
                
                // Handle window resize with debounce
                let resizeTimeout;
                window.addEventListener('resize', function() {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(function() {
                        console.log("Window resized, redrawing visualizations...");
                        drawWaveFunction();
                        drawCorrelation();
                        drawHolographic();
                    }, 250);
                });
                
                // Animate in sections
                animateSections();
                
                // Hide error message if successful
                document.getElementById('error-message').style.display = 'none';
            } catch (error) {
                console.error('Visualization error:', error);
                document.getElementById('error-message').style.display = 'block';
                document.getElementById('error-message').textContent = 'Error initializing visualizations: ' + error.message;
            }
        }
        
        // Animation for sections
        function animateSections() {
            const sections = document.querySelectorAll('.visualization-section');
            
            sections.forEach(section => {
                const delay = parseInt(section.getAttribute('data-animation-delay')) || 0;
                
                setTimeout(() => {
                    section.classList.add('loaded');
                }, delay);
            });
        }
        
        // Call initialization when DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initVisualizations);
        } else {
            // DOM already loaded, initialize immediately
            initVisualizations();
        }
        
        // Fallback timer in case the DOMContentLoaded event already fired or doesn't trigger properly
        setTimeout(function() {
            console.log("Fallback timer triggered for initialization");
            initVisualizations();
        }, 500);
    </script>
    
    <!-- React component for Hidden Order Parameter Visualization -->
    <script type="text/babel">
        // Hidden Order Parameter Visualization Component
        const HiddenOrderParameterVisualization = () => {
          // Get Recharts components from the global Recharts object
          const { 
            LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, 
            ResponsiveContainer, ScatterChart, Scatter, ZAxis 
          } = window.Recharts;
          
          const [separationMode, setSeparationMode] = React.useState('distance');
          const [orderMode, setOrderMode] = React.useState('standard');
          const [isLoading, setIsLoading] = React.useState(true);
          
          React.useEffect(() => {
            // Simulate loading delay for better UX
            const timer = setTimeout(() => {
              setIsLoading(false);
            }, 800);
            
            return () => clearTimeout(timer);
          }, []);
          
          // Generate data showing how mutual information (hidden order parameter H) 
          // varies with distance or entanglement between regions
          const generateHiddenOrderData = (mode, orderType) => {
            const data = [];
            
            // Parameters that control the behavior of the hidden order
            const entropyBase = orderType === 'standard' ? 1.0 : 2.0;
            const decayRate = orderType === 'standard' ? 0.4 : 0.1;
            const fluctuation = orderType === 'standard' ? 0.0 : 0.2;
            
            for (let x = 0.1; x <= 10; x += 0.2) {
              // Calculate entanglement entropies based on the distance or entanglement
              const size = mode === 'distance' ? 1.0 : (1.5 + Math.sin(x));
              
              // Entanglement entropy of region A
              const entropyA = entropyBase * Math.log(size);
              
              // Entanglement entropy of region B
              const entropyB = entropyBase * Math.log(size);
              
              // Entanglement entropy of the union, which increases with distance
              // and has a slower growth than the sum of individual entropies
              let entropyUnion;
              if (mode === 'distance') {
                // For distance mode: mutual information decreases with distance
                entropyUnion = entropyA + entropyB - entropyBase * Math.exp(-decayRate * x);
              } else {
                // For entanglement mode: mutual information correlates with entanglement
                entropyUnion = entropyA + entropyB - entropyBase * (1 - Math.exp(-decayRate * x));
              }
              
              // Add some quantum fluctuations to the data if in "quantum" mode
              const randomFluctuation = orderType === 'quantum' ? 
                fluctuation * (Math.random() - 0.5) * Math.exp(-x/5) : 0;
              
              // Calculate the hidden order parameter H = I(A:B) = S_A + S_B - S_{A∪B}
              const hiddenOrderH = entropyA + entropyB - entropyUnion + randomFluctuation;
              
              data.push({
                x: x,
                entropyA: entropyA,
                entropyB: entropyB,
                entropyUnion: entropyUnion,
                hiddenOrderH: hiddenOrderH,
                // Include values for additional plots
                theoretical: mode === 'distance' ? 
                  entropyBase * Math.exp(-decayRate * x) : 
                  entropyBase * (1 - Math.exp(-decayRate * x))
              });
            }
            
            return data;
          };
          
          // Generate the data based on current mode
          const hiddenOrderData = generateHiddenOrderData(separationMode, orderMode);
          
          // Create another dataset for the phase transition
          const generatePhaseTransitionData = () => {
            const data = [];
            
            // Parameter that controls the transition point
            const criticalPoint = 5.0;
            const sharpness = 3.0;
            
            for (let x = 0.1; x <= 10; x += 0.2) {
              const beforeTransition = 0.05 + 0.8 / (1 + Math.exp(sharpness * (x - criticalPoint)));
              
              // Add some quantum fluctuations near the critical point
              const criticalFluctuations = 0.1 * Math.exp(-2 * Math.pow(x - criticalPoint, 2));
              
              data.push({
                x: x,
                hiddenOrderH: beforeTransition + (orderMode === 'quantum' ? criticalFluctuations : 0),
                criticalPoint: x === criticalPoint ? beforeTransition / 2 : null,
              });
            }
            
            return data;
          };
          
          const phaseTransitionData = generatePhaseTransitionData();

          if (isLoading) {
            return (
              <div className="loading-spinner">
                <div className="spinner"></div>
              </div>
            );
          }

          return (
            <div style={{ padding: '20px', borderRadius: '8px' }}>
              <h2 style={{ textAlign: 'center', marginBottom: '20px' }}>
                Hidden Order Parameter Visualization
              </h2>
              
              <div style={{ display: 'flex', justifyContent: 'center', marginBottom: '20px', gap: '20px' }}>
                <div>
                  <label style={{ marginRight: '10px', fontWeight: 'bold' }}>Separation Type:</label>
                  <select 
                    value={separationMode} 
                    onChange={(e) => setSeparationMode(e.target.value)}
                    style={{ padding: '5px', borderRadius: '4px', backgroundColor: '#30363d', color: '#e0e0e0', border: '1px solid #58a6ff' }}
                  >
                    <option value="distance">Spatial Distance</option>
                    <option value="entanglement">Entanglement Strength</option>
                  </select>
                </div>
                <div>
                  <label style={{ marginRight: '10px', fontWeight: 'bold' }}>Order Type:</label>
                  <select 
                    value={orderMode} 
                    onChange={(e) => setOrderMode(e.target.value)}
                    style={{ padding: '5px', borderRadius: '4px', backgroundColor: '#30363d', color: '#e0e0e0', border: '1px solid #58a6ff' }}
                  >
                    <option value="standard">Standard</option>
                    <option value="quantum">Quantum Fluctuations</option>
                  </select>
                </div>
              </div>
              
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px' }}>
                {/* Hidden Order Parameter vs Distance/Entanglement */}
                <div style={{ backgroundColor: '#0d1117', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
                  <h3 style={{ marginTop: '0', color: '#58a6ff' }}>
                    Hidden Order Parameter (H = I(A:B))
                  </h3>
                  <p style={{ fontSize: '14px', color: '#8b949e' }}>
                    H = S<sub>A</sub> + S<sub>B</sub> - S<sub>A∪B</sub> where S is the entanglement entropy
                  </p>
                  <div style={{ height: '300px' }}>
                    <ResponsiveContainer width="100%" height="100%">
                      <LineChart data={hiddenOrderData} margin={{ top: 5, right: 30, left: 20, bottom: 40 }}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#30363d" />
                        <XAxis 
                          dataKey="x" 
                          stroke="#8b949e"
                          label={{ 
                            value: separationMode === 'distance' ? 'Spatial Separation' : 'Entanglement Strength', 
                            position: 'insideBottom', 
                            offset: -5,
                            style: { textAnchor: 'middle', fill: '#8b949e' }
                          }}
                        />
                        <YAxis 
                          stroke="#8b949e"
                          label={{ 
                            value: 'Hidden Order Parameter (H)', 
                            angle: -90, 
                            position: 'insideLeft',
                            style: { textAnchor: 'middle', fill: '#8b949e' } 
                          }}
                        />
                        <Tooltip 
                          formatter={(value) => value.toFixed(3)}
                          contentStyle={{ backgroundColor: '#0d1117', border: '1px solid #30363d', color: '#e0e0e0' }}
                        />
                        <Legend verticalAlign="top" />
                        <Line 
                          type="monotone" 
                          dataKey="hiddenOrderH" 
                          stroke="#8884d8" 
                          name="Hidden Order (H)" 
                          strokeWidth={2}
                          dot={false}
                        />
                        <Line 
                          type="monotone" 
                          dataKey="theoretical" 
                          stroke="#82ca9d" 
                          name="Theoretical Model" 
                          strokeWidth={2}
                          strokeDasharray="5 5"
                          dot={false}
                        />
                      </LineChart>
                    </ResponsiveContainer>
                  </div>
                  <p style={{ fontSize: '12px', color: '#8b949e', marginTop: '10px' }}>
                    {separationMode === 'distance' ? 
                      "As spatial separation increases, hidden order (mutual information) decreases exponentially, demonstrating the decay of quantum correlations with distance." :
                      "As entanglement strength increases, hidden order increases, showing how stronger quantum correlations enhance the hidden order parameter."}
                  </p>
                </div>
                
                {/* Entanglement Entropy Components Graph */}
                <div style={{ backgroundColor: '#0d1117', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
                  <h3 style={{ marginTop: '0', color: '#58a6ff' }}>
                    Entanglement Entropy Components
                  </h3>
                  <p style={{ fontSize: '14px', color: '#8b949e' }}>
                    Showing S<sub>A</sub>, S<sub>B</sub>, and S<sub>A∪B</sub> used to calculate H
                  </p>
                  <div style={{ height: '300px' }}>
                    <ResponsiveContainer width="100%" height="100%">
                      <LineChart data={hiddenOrderData} margin={{ top: 5, right: 30, left: 20, bottom: 40 }}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#30363d" />
                        <XAxis 
                          dataKey="x" 
                          stroke="#8b949e"
                          label={{ 
                            value: separationMode === 'distance' ? 'Spatial Separation' : 'Entanglement Strength', 
                            position: 'insideBottom', 
                            offset: -5,
                            style: { fill: '#8b949e' }
                          }}
                        />
                        <YAxis 
                          stroke="#8b949e"
                          label={{ 
                            value: 'Entanglement Entropy', 
                            angle: -90, 
                            position: 'insideLeft',
                            style: { fill: '#8b949e' }
                          }}
                        />
                        <Tooltip 
                          formatter={(value) => value.toFixed(3)}
                          contentStyle={{ backgroundColor: '#0d1117', border: '1px solid #30363d', color: '#e0e0e0' }}
                        />
                        <Legend verticalAlign="top" />
                        <Line 
                          type="monotone" 
                          dataKey="entropyA" 
                          stroke="#ff7300" 
                          name="S_A (Region A)" 
                          dot={false}
                          strokeWidth={2}
                        />
                        <Line 
                          type="monotone" 
                          dataKey="entropyB" 
                          stroke="#0088fe" 
                          name="S_B (Region B)" 
                          dot={false}
                          strokeWidth={2}
                        />
                        <Line 
                          type="monotone" 
                          dataKey="entropyUnion" 
                          stroke="#00C49F" 
                          name="S_A∪B (Union)" 
                          dot={false}
                          strokeWidth={2}
                        />
                      </LineChart>
                    </ResponsiveContainer>
                  </div>
                  <p style={{ fontSize: '12px', color: '#8b949e', marginTop: '10px' }}>
                    The difference between the sum of individual entropies (S<sub>A</sub> + S<sub>B</sub>) and the union entropy (S<sub>A∪B</sub>) 
                    represents the hidden order parameter H. When the difference is large, strong quantum correlations exist between regions.
                  </p>
                </div>
                
                {/* Phase Transition */}
                <div style={{ backgroundColor: '#0d1117', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
                  <h3 style={{ marginTop: '0', color: '#58a6ff' }}>
                    Hidden Order Phase Transition
                  </h3>
                  <p style={{ fontSize: '14px', color: '#8b949e' }}>
                    Showing how a system transitions between ordered and disordered phases
                  </p>
                  <div style={{ height: '300px' }}>
                    <ResponsiveContainer width="100%" height="100%">
                      <LineChart data={phaseTransitionData} margin={{ top: 5, right: 30, left: 20, bottom: 40 }}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#30363d" />
                        <XAxis 
                          dataKey="x" 
                          stroke="#8b949e"
                          label={{ 
                            value: 'System Parameter (e.g., Temperature)', 
                            position: 'insideBottom', 
                            offset: -5,
                            style: { fill: '#8b949e' }
                          }}
                        />
                        <YAxis 
                          stroke="#8b949e"
                          label={{ 
                            value: 'Hidden Order Parameter (H)', 
                            angle: -90, 
                            position: 'insideLeft',
                            style: { fill: '#8b949e' }
                          }}
                        />
                        <Tooltip 
                          formatter={(value) => value !== null ? value.toFixed(3) : 'N/A'}
                          contentStyle={{ backgroundColor: '#0d1117', border: '1px solid #30363d', color: '#e0e0e0' }}
                        />
                        <Legend verticalAlign="top" />
                        <Line 
                          type="monotone" 
                          dataKey="hiddenOrderH" 
                          stroke="#8884d8" 
                          name="Hidden Order (H)" 
                          dot={false}
                          strokeWidth={2}
                        />
                        <Scatter
                          name="Critical Point"
                          data={phaseTransitionData.filter(item => item.criticalPoint !== null)}
                          fill="red"
                          shape="star"
                          dataKey="criticalPoint"
                        />
                      </LineChart>
                    </ResponsiveContainer>
                  </div>
                  <p style={{ fontSize: '12px', color: '#8b949e', marginTop: '10px' }}>
                    As the system parameter increases, the hidden order parameter undergoes a phase transition. 
                    Below the critical point, strong correlations exist (high hidden order). Above it, the system transitions 
                    to a disordered state with minimal hidden order.
                  </p>
                </div>
                
                {/* 3D Visualization */}
                <div style={{ backgroundColor: '#0d1117', padding: '15px', borderRadius: '8px', border: '1px solid #30363d' }}>
                  <h3 style={{ marginTop: '0', color: '#58a6ff' }}>
                    Hidden Order in 3D Parameter Space
                  </h3>
                  <p style={{ fontSize: '14px', color: '#8b949e' }}>
                    Visualizing how hidden order varies with multiple parameters
                  </p>
                  <div style={{ height: '300px' }}>
                    <ResponsiveContainer width="100%" height="100%">
                      <ScatterChart margin={{ top: 20, right: 20, bottom: 40, left: 20 }}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#30363d" />
                        <XAxis 
                          type="number" 
                          dataKey="x" 
                          name="Parameter 1" 
                          domain={[0, 10]}
                          stroke="#8b949e"
                          label={{ value: 'Parameter 1', position: 'insideBottom', offset: -5, style: { fill: '#8b949e' } }}
                        />
                        <YAxis 
                          type="number" 
                          dataKey="hiddenOrderH" 
                          name="Hidden Order (H)" 
                          stroke="#8b949e"
                          label={{ value: 'Hidden Order (H)', angle: -90, position: 'insideLeft', style: { fill: '#8b949e' } }}
                        />
                        <ZAxis 
                          type="number" 
                          dataKey="theoretical" 
                          range={[20, 200]} 
                          name="Parameter 2" 
                        />
                        <Tooltip 
                          cursor={{ strokeDasharray: '3 3' }} 
                          formatter={(value, name) => [value.toFixed(3), name]}
                          contentStyle={{ backgroundColor: '#0d1117', border: '1px solid #30363d', color: '#e0e0e0' }}
                        />
                        <Legend />
                        <Scatter 
                          name="Hidden Order in Parameter Space" 
                          data={hiddenOrderData} 
                          fill="#8884d8"
                        />
                      </ScatterChart>
                    </ResponsiveContainer>
                  </div>
                  <p style={{ fontSize: '12px', color: '#8b949e', marginTop: '10px' }}>
                    This 3D visualization shows how hidden order varies across multiple parameters. 
                    The size of each point represents a third parameter value, showing regions of parameter 
                    space where hidden order is maximized (larger points indicate stronger correlation with 
                    the theoretical model).
                  </p>
                </div>
              </div>
              
              <div style={{ backgroundColor: '#0d1117', padding: '15px', borderRadius: '8px', border: '1px solid #30363d', marginTop: '20px' }}>
                <h3 style={{ marginTop: '0', color: '#58a6ff' }}>Key Insights about Hidden Order Parameter</h3>
                <ul style={{ fontSize: '14px', color: '#8b949e' }}>
                  <li><strong>Definition:</strong> H = I(A:B) = S<sub>A</sub> + S<sub>B</sub> - S<sub>A∪B</sub> captures non-local quantum correlations</li>
                  <li><strong>Physical Meaning:</strong> When H > 0, regions A and B share information despite spatial separation</li>
                  <li><strong>Decay Properties:</strong> Hidden order typically decays with distance but can be enhanced by entanglement</li>
                  <li><strong>Phase Transitions:</strong> Systems can transition between ordered (H > 0) and disordered (H ≈ 0) phases</li>
                  <li><strong>Quantum Fluctuations:</strong> Can lead to local variations in hidden order strength, especially near critical points</li>
                  <li><strong>Experimental Detection:</strong> Can be measured through mutual information in quantum many-body systems</li>
                </ul>
              </div>
            </div>
          );
        };

        // Render the React component when the DOM is fully loaded
        function initReactComponent() {
          if (typeof React !== 'undefined' && typeof ReactDOM !== 'undefined' && typeof Recharts !== 'undefined') {
            console.log("All libraries loaded, rendering React component");
            try {
              ReactDOM.render(
                <HiddenOrderParameterVisualization />,
                document.getElementById('hidden-order-visualization-root')
              );
            } catch (error) {
              console.error("Error rendering Hidden Order React component:", error);
              document.getElementById('hidden-order-visualization-root').innerHTML = 
                '<div class="error-state">Error loading visualization component. Please refresh the page.</div>';
            }
          } else {
            console.error("Required libraries not loaded yet, retrying in 1 second");
            setTimeout(initReactComponent, 1000);
          }
        }
        
        // Try to initialize immediately if DOM is already loaded
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
          setTimeout(initReactComponent, 500); // Short delay to ensure libraries are loaded
        } else {
          document.addEventListener('DOMContentLoaded', function() {
            setTimeout(initReactComponent, 500);
          });
        }
        
        // Fallback initialization after 2 seconds regardless of DOM/library state
        setTimeout(initReactComponent, 2000);
    </script>

    <!-- Load our improved HQR visualization JavaScript -->
    <script src="hqr-visualization.js"></script>
    <script>
  // Check if components are loading
  document.addEventListener('DOMContentLoaded', function() {
    // Check for loading spinners that persist too long
    setTimeout(function() {
      const spinners = document.querySelectorAll('.loading-spinner');
      spinners.forEach(spinner => {
        // If a spinner is still visible after 10 seconds, show error
        if (spinner.offsetParent !== null) {
          const container = spinner.parentNode;
          container.innerHTML = `
            <div style="background-color: #2d0b0b; color: #f85149; padding: 15px; border-radius: 8px; border: 1px solid #f85149;">
              <h3 style="margin-top: 0;">Component Failed to Load</h3>
              <p>Check console for errors. Possible issues:</p>
              <ul>
                <li>JavaScript files not found - check file paths</li>
                <li>React/Recharts libraries not loading properly</li>
                <li>JavaScript errors in your component code</li>
              </ul>
              <button onclick="location.reload()" style="background: #30363d; color: #e0e0e0; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer;">Reload Page</button>
            </div>
          `;
        }
      });
    }, 10000); // 10 second timeout
  });
</script>
</body>
</html>
