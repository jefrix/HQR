<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HQR Simplified Visualizations</title>
    
    <!-- Basic styling -->
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        
        .header {
            padding: 20px;
            background-color: #0d1117;
            border-bottom: 1px solid #30363d;
        }
        
        .back-link {
            color: #58a6ff;
            text-decoration: none;
            display: inline-block;
            margin-bottom: 10px;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .intro {
            margin-bottom: 30px;
            line-height: 1.6;
        }
        
        .visualization-section {
            background-color: #161b22;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid #30363d;
        }
        
        h2 {
            color: #58a6ff;
            margin-top: 0;
        }
        
        .visualization-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        
        .visualization-card {
            flex: 1 1 400px;
            background-color: #0d1117;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #30363d;
        }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        select {
            background-color: #161b22;
            color: #e0e0e0;
            border: 1px solid #30363d;
            padding: 8px 12px;
            border-radius: 4px;
        }
        
        .chart-container {
            height: 300px;
            width: 100%;
            background-color: #0d1117;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }
        
        .chart-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        canvas {
            width: 100%;
            height: 100%;
        }
        
        .equation-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .equation-card {
            background-color: #0d1117;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #30363d;
        }
        
        .equation-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #58a6ff;
        }
        
        .equation {
            font-family: 'Courier New', monospace;
            padding: 10px;
            background-color: #161b22;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .equation-description {
            font-size: 0.9em;
            color: #8b949e;
        }
        
        .error-message {
            background-color: #2d0b0b;
            border: 1px solid #f85149;
            color: #f85149;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: none;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            border-top: 1px solid #30363d;
            color: #8b949e;
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="index.html" class="back-link">← Back to Main Page</a>
        <h1>HQR Mathematical Visualizations</h1>
    </div>
    
    <div class="container">
        <div class="intro">
            <p>These visualizations demonstrate the key mathematical components of Holonomic Quantum Reality (HQR) theory. Toggle between 4D and 11D representations to see how higher dimensions introduce additional complexity. Hover over elements to see detailed values and explore the relationships between different components of the theory.</p>
        </div>
        
        <div id="error-message" class="error-message">
            Unable to load interactive visualizations. Please ensure JavaScript is enabled in your browser.
        </div>
        
        <div class="visualization-section">
            <h2>Wave Function & Hidden Order</h2>
            
            <div class="controls">
                <div>
                    <label for="dimension-select">Choose Dimension: </label>
                    <select id="dimension-select" onchange="updateDimension(this.value)">
                        <option value="4D">4D Reality</option>
                        <option value="11D">11D M-Theory</option>
                    </select>
                </div>
                <div id="dimension-display">Currently viewing: 4D Reality</div>
            </div>
            
            <div class="visualization-container">
                <div class="visualization-card">
                    <h3>Bohmian Mechanics Wave Function (Ψ = Re<sup>iS/ℏ</sup>)</h3>
                    <p>Visualizing components of the wave function and velocity field from guiding equation: dx/dt = ∇S/m</p>
                    <div class="chart-container">
                        <canvas id="wave-function-canvas"></canvas>
                    </div>
                </div>
                
                <div class="visualization-card">
                    <h3>Hidden Order Correlation</h3>
                    <p>Visualizing correlation function ⟨O(x)O(y)⟩ as a projection from higher dimensions</p>
                    <div class="chart-container">
                        <canvas id="correlation-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="visualization-section">
            <h2>Holographic Principle: AdS/CFT Correspondence</h2>
            <p>Visualizing the relationship between bulk AdS space and boundary CFT: Z<sub>CFT</sub> = ∫Dϕe<sup>-S<sub>bulk</sub>[ϕ]</sup></p>
            
            <div class="chart-container">
                <canvas id="holographic-canvas"></canvas>
            </div>
        </div>
        
        <div class="visualization-section">
            <h2>Key Equations of HQR</h2>
            
            <div class="equation-container">
                <div class="equation-card">
                    <div class="equation-title">M-Theory Metric</div>
                    <div class="equation">ds² = g<sub>μν</sub>dx<sup>μ</sup>dx<sup>ν</sup>, μ,ν = 0,1,...,10</div>
                    <div class="equation-description">Describes spacetime in 11 dimensions, where the extra dimensions are compactified at scales too small to observe directly.</div>
                </div>
                
                <div class="equation-card">
                    <div class="equation-title">Bohmian Mechanics Guiding Equation</div>
                    <div class="equation">dx/dt = ∇S/m</div>
                    <div class="equation">Where Ψ = Re<sup>iS/ℏ</sup></div>
                    <div class="equation-description">Determines particle trajectories from the wave function, providing a deterministic interpretation of quantum mechanics.</div>
                </div>
                
                <div class="equation-card">
                    <div class="equation-title">Hidden Order Correlation</div>
                    <div class="equation">⟨O(x)O(y)⟩</div>
                    <div class="equation-description">Measures subtle, long-range quantum correlations in many-body systems, potentially arising from higher-dimensional dynamics.</div>
                </div>
                
                <div class="equation-card">
                    <div class="equation-title">AdS/CFT Correspondence</div>
                    <div class="equation">Z<sub>CFT</sub> = ∫Dϕe<sup>-S<sub>bulk</sub>[ϕ]</sup></div>
                    <div class="equation-description">Links boundary conformal field theory to bulk anti-de Sitter gravity, supporting the holographic principle in HQR.</div>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        © 2025 HQR Team | <a href="index.html" style="color: #58a6ff;">Return to Main Page</a>
    </footer>
    
    <script>
        // Simple JavaScript to handle dimension toggling and basic canvas drawing
        let currentDimension = '4D';
        
        // Update dimension display and redraw visualizations
        function updateDimension(dimension) {
            currentDimension = dimension;
            document.getElementById('dimension-display').textContent = 'Currently viewing: ' + dimension;
            
            // Redraw all visualizations with the new dimension
            drawWaveFunction();
            drawCorrelation();
            drawHolographic();
        }
        
        // Draw wave function visualization
        function drawWaveFunction() {
            const canvas = document.getElementById('wave-function-canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 0.5;
            
            // Vertical grid lines
            for (let x = 0; x <= canvas.width; x += 30) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let y = 0; y <= canvas.height; y += 30) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Center axes
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.strokeStyle = '#8b949e';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            
            // Draw curves
            const complexity = currentDimension === '4D' ? 1 : 2;
            
            // Real part curve
            ctx.strokeStyle = '#8884d8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let x = 0; x < canvas.width; x++) {
                // Map canvas x to wave function domain [-10, 10]
                const xValue = (x / canvas.width) * 20 - 10;
                
                // Calculate y from real part of wave function
                const amplitude = Math.exp(-xValue*xValue / 4);
                const phase = xValue*xValue / 2 * complexity;
                const realPart = amplitude * Math.cos(phase);
                
                // Map to canvas coordinates
                const y = centerY - realPart * (canvas.height * 0.4);
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Imaginary part curve
            ctx.strokeStyle = '#82ca9d';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let x = 0; x < canvas.width; x++) {
                const xValue = (x / canvas.width) * 20 - 10;
                const amplitude = Math.exp(-xValue*xValue / 4);
                const phase = xValue*xValue / 2 * complexity;
                const imagPart = amplitude * Math.sin(phase);
                const y = centerY - imagPart * (canvas.height * 0.4);
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Hidden order correlation (dashed line)
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            
            for (let x = 0; x < canvas.width; x++) {
                const xValue = (x / canvas.width) * 20 - 10;
                const amplitude = Math.exp(-xValue*xValue / 4);
                const hiddenOrder = amplitude * Math.cos(complexity * xValue / 2) * Math.exp(-Math.abs(xValue) / 5);
                const y = centerY - hiddenOrder * (canvas.height * 0.4);
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Reset line dash
            ctx.setLineDash([]);
            
            // Legend
            const legendItems = [
                { color: '#8884d8', label: 'Real Part (Re[Ψ])' },
                { color: '#82ca9d', label: 'Imaginary Part (Im[Ψ])' },
                { color: '#ff0000', label: 'Hidden Order ⟨O(x)O(0)⟩' }
            ];
            
            ctx.font = '12px Arial';
            let legendY = 20;
            
            legendItems.forEach(item => {
                // Color box
                ctx.fillStyle = item.color;
                ctx.fillRect(10, legendY, 15, 15);
                
                // Label
                ctx.fillStyle = '#e0e0e0';
                ctx.fillText(item.label, 35, legendY + 12);
                
                legendY += 25;
            });
        }
        
        // Draw correlation visualization
        function drawCorrelation() {
            const canvas = document.getElementById('correlation-canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 0.5;
            
            // Vertical grid lines
            for (let x = 0; x <= canvas.width; x += 30) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let y = 0; y <= canvas.height; y += 30) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Center axes
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.strokeStyle = '#8b949e';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            
            // Draw correlation points
            const complexity = currentDimension === '4D' ? 1 : 2;
            const resolution = 20;
            
            for (let i = 0; i <= resolution; i++) {
                const u = (i / resolution) * Math.PI * 2;
                for (let j = 0; j <= resolution; j++) {
                    const v = (j / resolution) * Math.PI;
                    
                    // Parametric equations for projection
                    let x, y;
                    
                    if (currentDimension === '4D') {
                        x = Math.sin(u) * Math.sin(v);
                        y = Math.sin(u) * Math.cos(v);
                    } else {
                        x = Math.sin(u) * Math.sin(v) + 0.3 * Math.sin(3 * u);
                        y = Math.sin(u) * Math.cos(v) + 0.3 * Math.cos(2 * v);
                    }
                    
                    // Scale to canvas
                    x = centerX + x * (canvas.width * 0.4);
                    y = centerY - y * (canvas.height * 0.4);
                    
                    // Correlation intensity determines color
                    const correlation = Math.pow(Math.cos(complexity * u) * Math.sin(complexity * v), 2);
                    
                    // Blue color with varying intensity
                    const blue = Math.floor(150 + correlation * 105);
                    ctx.fillStyle = `rgb(50, 50, ${blue})`;
                    
                    // Draw point
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Legend
            ctx.font = '12px Arial';
            
            // Color gradient legend
            const gradientWidth = 150;
            const gradientHeight = 15;
            const gradientX = 10;
            const gradientY = 20;
            
            for (let i = 0; i < gradientWidth; i++) {
                const ratio = i / gradientWidth;
                const blue = Math.floor(150 + ratio * 105);
                ctx.fillStyle = `rgb(50, 50, ${blue})`;
                ctx.fillRect(gradientX + i, gradientY, 1, gradientHeight);
            }
            
            // Legend labels
            ctx.fillStyle = '#e0e0e0';
            ctx.fillText('Weak Correlation', gradientX, gradientY + gradientHeight + 15);
            ctx.fillText('Strong Correlation', gradientX + gradientWidth - 100, gradientY + gradientHeight + 15);
        }
        
        // Draw holographic visualization
        function drawHolographic() {
            const canvas = document.getElementById('holographic-canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Center and radius
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.4;
            
            // Draw boundary circle (CFT)
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw concentric circles (AdS bulk)
            const circles = [0.8, 0.6, 0.4, 0.2];
            
            circles.forEach((scale, idx) => {
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 1 + (1-scale) * 2;
                ctx.globalAlpha = 0.4 + ((1-scale) * 0.6);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * scale, 0, Math.PI * 2);
                ctx.stroke();
            });
            
            // Reset opacity
            ctx.globalAlpha = 1;
            
            // Draw radial lines
            const angles = [0, 45, 90, 135, 180, 225, 270, 315];
            
            angles.forEach(angle => {
                const radian = angle * Math.PI / 180;
                const x = centerX + Math.cos(radian) * radius;
                const y = centerY + Math.sin(radian) * radius;
                
                ctx.strokeStyle = '#93c5fd';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x, y);
                ctx.stroke();
            });
            
            // Reset opacity
            ctx.globalAlpha = 1;
            
            // Draw central point (deep bulk)
            ctx.fillStyle = '#1d4ed8';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw MERA tensor network for 11D
            if (currentDimension === '11D') {
                drawTensorNetwork(ctx, centerX, centerY, radius);
            }
            
            // Legend
            const legendItems = [
                { color: '#ef4444', label: 'CFT Boundary (Our 4D Reality)', type: 'line' },
                { color: '#1d4ed8', label: 'AdS Bulk (Higher Dimensions)', type: 'circle' }
            ];
            
            if (currentDimension === '11D') {
                legendItems.push({ color: '#93c5fd', label: 'MERA Tensor Network', type: 'line' });
            }
            
            ctx.font = '12px Arial';
            let legendY = 20;
            
            legendItems.forEach(item => {
                if (item.type === 'line') {
                    // Line
                    ctx.strokeStyle = item.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(10, legendY + 7);
                    ctx.lineTo(25, legendY + 7);
                    ctx.stroke();
                } else {
                    // Circle
                    ctx.fillStyle = item.color;
                    ctx.beginPath();
                    ctx.arc(17, legendY + 7, 7, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Label
                ctx.fillStyle = '#e0e0e0';
                ctx.fillText(item.label, 35, legendY + 12);
                
                legendY += 25;
            });
        }
        
        // Helper function to draw tensor network
        function drawTensorNetwork(ctx, centerX, centerY, radius) {
            ctx.globalAlpha = 0.4;
            
            // Define levels of the network
            const levels = [0, 1, 2, 3];
            
            // Draw nodes at each level
            levels.forEach(level => {
                const levelRadius = (level === 0) ? 10 : radius * (0.2 + level * 0.2);
                const nodesAtLevel = 4 + level * 2;
                
                for (let i = 0; i < nodesAtLevel; i++) {
                    const angle = (i / nodesAtLevel) * Math.PI * 2;
                    const x = centerX + levelRadius * Math.cos(angle);
                    const y = centerY + levelRadius * Math.sin(angle);
                    
                    // Node color based on level
                    if (level === 0) {
                        ctx.fillStyle = '#1d4ed8';
                    } else if (level === 3) {
                        ctx.fillStyle = '#ef4444';
                    } else {
                        ctx.fillStyle = '#3b82f6';
                    }
                    
                    // Draw node
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw connections between adjacent levels
            for (let level = 0; level < 3; level++) {
                const innerRadius = (level === 0) ? 10 : radius * (0.2 + level * 0.2);
                const outerRadius = radius * (0.2 + (level + 1) * 0.2);
                const innerNodes = 4 + level * 2;
                const outerNodes = 4 + (level + 1) * 2;
                
                for (let i = 0; i < innerNodes; i++) {
                    const innerAngle = (i / innerNodes) * Math.PI * 2;
                    const x1 = centerX + innerRadius * Math.cos(innerAngle);
                    const y1 = centerY + innerRadius * Math.sin(innerAngle);
                    
                    // Connect each inner node to two outer nodes
                    for (let j of [i*2, i*2+1]) {
                        if (j < outerNodes) {
                            const outerAngle = (j / outerNodes) * Math.PI * 2;
                            const x2 = centerX + outerRadius * Math.cos(outerAngle);
                            const y2 = centerY + outerRadius * Math.sin(outerAngle);
                            
                            // Connection color
                            ctx.strokeStyle = (level === 2) ? '#fca5a5' : '#93c5fd';
                            ctx.lineWidth = 1;
                            
                            // Draw connection
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // Reset opacity
            ctx.globalAlpha = 1;
        }
        
        // Initialize visualizations
        function initVisualizations() {
            try {
                drawWaveFunction();
                drawCorrelation();
                drawHolographic();
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    drawWaveFunction();
                    drawCorrelation();
                    drawHolographic();
                });
                
                // Hide error message if successful
                document.getElementById('error-message').style.display = 'none';
            } catch (error) {
                console.error('Visualization error:', error);
                document.getElementById('error-message').style.display = 'block';
            }
        }
        
        // Call initialization when DOM is loaded
        document.addEventListener('DOMContentLoaded', initVisualizations);
    </script>


    // new stufffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    
<!-- Add this script block after your existing visualization section -->
<script type="text/babel">
// Hidden Order Parameter Visualization Component
const HiddenOrderParameterVisualization = () => {
  const [separationMode, setSeparationMode] = React.useState('distance');
  const [orderMode, setOrderMode] = React.useState('standard');
  
  // Generate data showing how mutual information (hidden order parameter H) 
  // varies with distance or entanglement between regions
  const generateHiddenOrderData = (mode, orderType) => {
    const data = [];
    
    // Parameters that control the behavior of the hidden order
    const entropyBase = orderType === 'standard' ? 1.0 : 2.0;
    const decayRate = orderType === 'standard' ? 0.4 : 0.1;
    const fluctuation = orderType === 'standard' ? 0.0 : 0.2;
    
    for (let x = 0.1; x <= 10; x += 0.2) {
      // Calculate entanglement entropies based on the distance or entanglement
      const size = mode === 'distance' ? 1.0 : (1.5 + Math.sin(x));
      
      // Entanglement entropy of region A
      const entropyA = entropyBase * Math.log(size);
      
      // Entanglement entropy of region B
      const entropyB = entropyBase * Math.log(size);
      
      // Entanglement entropy of the union, which increases with distance
      // and has a slower growth than the sum of individual entropies
      let entropyUnion;
      if (mode === 'distance') {
        // For distance mode: mutual information decreases with distance
        entropyUnion = entropyA + entropyB - entropyBase * Math.exp(-decayRate * x);
      } else {
        // For entanglement mode: mutual information correlates with entanglement
        entropyUnion = entropyA + entropyB - entropyBase * (1 - Math.exp(-decayRate * x));
      }
      
      // Add some quantum fluctuations to the data if in "quantum" mode
      const randomFluctuation = orderType === 'quantum' ? 
        fluctuation * (Math.random() - 0.5) * Math.exp(-x/5) : 0;
      
      // Calculate the hidden order parameter H = I(A:B) = S_A + S_B - S_{A∪B}
      const hiddenOrderH = entropyA + entropyB - entropyUnion + randomFluctuation;
      
      data.push({
        x: x,
        entropyA: entropyA,
        entropyB: entropyB,
        entropyUnion: entropyUnion,
        hiddenOrderH: hiddenOrderH,
        // Include values for additional plots
        theoretical: mode === 'distance' ? 
          entropyBase * Math.exp(-decayRate * x) : 
          entropyBase * (1 - Math.exp(-decayRate * x))
      });
    }
    
    return data;
  };
  
  // Generate the data based on current mode
  const hiddenOrderData = generateHiddenOrderData(separationMode, orderMode);
  
  // Create another dataset for the phase transition
  const generatePhaseTransitionData = () => {
    const data = [];
    
    // Parameter that controls the transition point
    const criticalPoint = 5.0;
    const sharpness = 3.0;
    
    for (let x = 0.1; x <= 10; x += 0.2) {
      const beforeTransition = 0.05 + 0.8 / (1 + Math.exp(sharpness * (x - criticalPoint)));
      
      // Add some quantum fluctuations near the critical point
      const criticalFluctuations = 0.1 * Math.exp(-2 * Math.pow(x - criticalPoint, 2));
      
      data.push({
        x: x,
        hiddenOrderH: beforeTransition + (orderMode === 'quantum' ? criticalFluctuations : 0),
        criticalPoint: x === criticalPoint ? beforeTransition / 2 : null,
      });
    }
    
    return data;
  };
  
  const phaseTransitionData = generatePhaseTransitionData();

  // Get Recharts components
  const { 
    LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, 
    ResponsiveContainer, ScatterChart, Scatter, ZAxis 
  } = Recharts;

  return (
    <div style={{ fontFamily: 'Arial, sans-serif', padding: '20px', backgroundColor: '#f5f5f5', borderRadius: '8px' }}>
      <h2 style={{ color: '#333', textAlign: 'center', marginBottom: '20px' }}>
        Hidden Order Parameter Visualization
      </h2>
      
      <div style={{ display: 'flex', justifyContent: 'center', marginBottom: '20px', gap: '20px' }}>
        <div>
          <label style={{ marginRight: '10px', fontWeight: 'bold' }}>Separation Type:</label>
          <select 
            value={separationMode} 
            onChange={(e) => setSeparationMode(e.target.value)}
            style={{ padding: '5px', borderRadius: '4px' }}
          >
            <option value="distance">Spatial Distance</option>
            <option value="entanglement">Entanglement Strength</option>
          </select>
        </div>
        <div>
          <label style={{ marginRight: '10px', fontWeight: 'bold' }}>Order Type:</label>
          <select 
            value={orderMode} 
            onChange={(e) => setOrderMode(e.target.value)}
            style={{ padding: '5px', borderRadius: '4px' }}
          >
            <option value="standard">Standard</option>
            <option value="quantum">Quantum Fluctuations</option>
          </select>
        </div>
      </div>
      
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px' }}>
        {/* Hidden Order Parameter vs Distance/Entanglement */}
        <div style={{ backgroundColor: 'white', padding: '15px', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>
          <h3 style={{ color: '#333', marginTop: '0' }}>
            Hidden Order Parameter (H = I(A:B))
          </h3>
          <p style={{ fontSize: '14px', color: '#666' }}>
            H = S<sub>A</sub> + S<sub>B</sub> - S<sub>A∪B</sub> where S is the entanglement entropy
          </p>
          <div style={{ height: '300px' }}>
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={hiddenOrderData} margin={{ top: 5, right: 30, left: 20, bottom: 40 }}>
                <CartesianGrid strokeDasharray="3 3" opacity={0.3} />
                <XAxis 
                  dataKey="x" 
                  label={{ 
                    value: separationMode === 'distance' ? 'Spatial Separation' : 'Entanglement Strength', 
                    position: 'insideBottom', 
                    offset: -5,
                    style: { textAnchor: 'middle' }
                  }}
                />
                <YAxis 
                  label={{ 
                    value: 'Hidden Order Parameter (H)', 
                    angle: -90, 
                    position: 'insideLeft',
                    style: { textAnchor: 'middle' } 
                  }}
                />
                <Tooltip formatter={(value) => value.toFixed(3)} />
                <Legend verticalAlign="top" />
                <Line 
                  type="monotone" 
                  dataKey="hiddenOrderH" 
                  stroke="#8884d8" 
                  name="Hidden Order (H)" 
                  strokeWidth={2}
                  dot={false}
                />
                <Line 
                  type="monotone" 
                  dataKey="theoretical" 
                  stroke="#82ca9d" 
                  name="Theoretical Model" 
                  strokeWidth={2}
                  strokeDasharray="5 5"
                  dot={false}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
          <p style={{ fontSize: '12px', color: '#666', marginTop: '10px' }}>
            {separationMode === 'distance' ? 
              "As spatial separation increases, hidden order (mutual information) decreases exponentially, demonstrating the decay of quantum correlations with distance." :
              "As entanglement strength increases, hidden order increases, showing how stronger quantum correlations enhance the hidden order parameter."}
          </p>
        </div>
        
        {/* Entanglement Entropy Components Graph */}
        <div style={{ backgroundColor: 'white', padding: '15px', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>
          <h3 style={{ color: '#333', marginTop: '0' }}>
            Entanglement Entropy Components
          </h3>
          <p style={{ fontSize: '14px', color: '#666' }}>
            Showing S<sub>A</sub>, S<sub>B</sub>, and S<sub>A∪B</sub> used to calculate H
          </p>
          <div style={{ height: '300px' }}>
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={hiddenOrderData} margin={{ top: 5, right: 30, left: 20, bottom: 40 }}>
                <CartesianGrid strokeDasharray="3 3" opacity={0.3} />
                <XAxis 
                  dataKey="x" 
                  label={{ 
                    value: separationMode === 'distance' ? 'Spatial Separation' : 'Entanglement Strength', 
                    position: 'insideBottom', 
                    offset: -5 
                  }}
                />
                <YAxis 
                  label={{ 
                    value: 'Entanglement Entropy', 
                    angle: -90, 
                    position: 'insideLeft' 
                  }}
                />
                <Tooltip formatter={(value) => value.toFixed(3)} />
                <Legend verticalAlign="top" />
                <Line 
                  type="monotone" 
                  dataKey="entropyA" 
                  stroke="#ff7300" 
                  name="S_A (Region A)" 
                  dot={false}
                  strokeWidth={2}
                />
                <Line 
                  type="monotone" 
                  dataKey="entropyB" 
                  stroke="#0088fe" 
                  name="S_B (Region B)" 
                  dot={false}
                  strokeWidth={2}
                />
                <Line 
                  type="monotone" 
                  dataKey="entropyUnion" 
                  stroke="#00C49F" 
                  name="S_A∪B (Union)" 
                  dot={false}
                  strokeWidth={2}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
          <p style={{ fontSize: '12px', color: '#666', marginTop: '10px' }}>
            The difference between the sum of individual entropies (S<sub>A</sub> + S<sub>B</sub>) and the union entropy (S<sub>A∪B</sub>) 
            represents the hidden order parameter H. When the difference is large, strong quantum correlations exist between regions.
          </p>
        </div>
        
        {/* Phase Transition */}
        <div style={{ backgroundColor: 'white', padding: '15px', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>
          <h3 style={{ color: '#333', marginTop: '0' }}>
            Hidden Order Phase Transition
          </h3>
          <p style={{ fontSize: '14px', color: '#666' }}>
            Showing how a system transitions between ordered and disordered phases
          </p>
          <div style={{ height: '300px' }}>
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={phaseTransitionData} margin={{ top: 5, right: 30, left: 20, bottom: 40 }}>
                <CartesianGrid strokeDasharray="3 3" opacity={0.3} />
                <XAxis 
                  dataKey="x" 
                  label={{ 
                    value: 'System Parameter (e.g., Temperature)', 
                    position: 'insideBottom', 
                    offset: -5 
                  }}
                />
                <YAxis 
                  label={{ 
                    value: 'Hidden Order Parameter (H)', 
                    angle: -90, 
                    position: 'insideLeft' 
                  }}
                />
                <Tooltip formatter={(value) => value !== null ? value.toFixed(3) : 'N/A'} />
                <Legend verticalAlign="top" />
                <Line 
                  type="monotone" 
                  dataKey="hiddenOrderH" 
                  stroke="#8884d8" 
                  name="Hidden Order (H)" 
                  dot={false}
                  strokeWidth={2}
                />
                <Scatter
                  name="Critical Point"
                  data={phaseTransitionData.filter(item => item.criticalPoint !== null)}
                  fill="red"
                  shape="star"
                  dataKey="criticalPoint"
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
          <p style={{ fontSize: '12px', color: '#666', marginTop: '10px' }}>
            As the system parameter increases, the hidden order parameter undergoes a phase transition. 
            Below the critical point, strong correlations exist (high hidden order). Above it, the system transitions 
            to a disordered state with minimal hidden order.
          </p>
        </div>
        
        {/* 3D Visualization */}
        <div style={{ backgroundColor: 'white', padding: '15px', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>
          <h3 style={{ color: '#333', marginTop: '0' }}>
            Hidden Order in 3D Parameter Space
          </h3>
          <p style={{ fontSize: '14px', color: '#666' }}>
            Visualizing how hidden order varies with multiple parameters
          </p>
          <div style={{ height: '300px' }}>
            <ResponsiveContainer width="100%" height="100%">
              <ScatterChart margin={{ top: 20, right: 20, bottom: 40, left: 20 }}>
                <CartesianGrid strokeDasharray="3 3" opacity={0.3} />
                <XAxis 
                  type="number" 
                  dataKey="x" 
                  name="Parameter 1" 
                  domain={[0, 10]}
                  label={{ value: 'Parameter 1', position: 'insideBottom', offset: -5 }}
                />
                <YAxis 
                  type="number" 
                  dataKey="hiddenOrderH" 
                  name="Hidden Order (H)" 
                  label={{ value: 'Hidden Order (H)', angle: -90, position: 'insideLeft' }}
                />
                <ZAxis 
                  type="number" 
                  dataKey="theoretical" 
                  range={[20, 200]} 
                  name="Parameter 2" 
                />
                <Tooltip 
                  cursor={{ strokeDasharray: '3 3' }} 
                  formatter={(value, name) => [value.toFixed(3), name]}
                />
                <Legend />
                <Scatter 
                  name="Hidden Order in Parameter Space" 
                  data={hiddenOrderData} 
                  fill="#8884d8"
                />
              </ScatterChart>
            </ResponsiveContainer>
          </div>
          <p style={{ fontSize: '12px', color: '#666', marginTop: '10px' }}>
            This 3D visualization shows how hidden order varies across multiple parameters. 
            The size of each point represents a third parameter value, showing regions of parameter 
            space where hidden order is maximized (larger points indicate stronger correlation with 
            the theoretical model).
          </p>
        </div>
      </div>
      
      <div style={{ backgroundColor: 'white', padding: '15px', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)', marginTop: '20px' }}>
        <h3 style={{ color: '#333', marginTop: '0' }}>Key Insights about Hidden Order Parameter</h3>
        <ul style={{ fontSize: '14px', color: '#333' }}>
          <li><strong>Definition:</strong> H = I(A:B) = S<sub>A</sub> + S<sub>B</sub> - S<sub>A∪B</sub> captures non-local quantum correlations</li>
          <li><strong>Physical Meaning:</strong> When H > 0, regions A and B share information despite spatial separation</li>
          <li><strong>Decay Properties:</strong> Hidden order typically decays with distance but can be enhanced by entanglement</li>
          <li><strong>Phase Transitions:</strong> Systems can transition between ordered (H > 0) and disordered (H ≈ 0) phases</li>
          <li><strong>Quantum Fluctuations:</strong> Can lead to local variations in hidden order strength, especially near critical points</li>
          <li><strong>Experimental Detection:</strong> Can be measured through mutual information in quantum many-body systems</li>
        </ul>
      </div>
    </div>
  );
};

// Render the hidden order visualization
ReactDOM.render(
  <HiddenOrderParameterVisualization />,
  document.getElementById('hidden-order-visualization-root')
);
</script>


    <div id="hidden-order-visualization-root"></div>
</div>

</body>
</html>
