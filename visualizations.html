<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HQR Simplified Visualizations</title>
    
    <!-- Basic styling -->
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        
        .header {
            padding: 20px;
            background-color: #0d1117;
            border-bottom: 1px solid #30363d;
        }
        
        .back-link {
            color: #58a6ff;
            text-decoration: none;
            display: inline-block;
            margin-bottom: 10px;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .intro {
            margin-bottom: 30px;
            line-height: 1.6;
        }
        
        .visualization-section {
            background-color: #161b22;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid #30363d;
        }
        
        h2 {
            color: #58a6ff;
            margin-top: 0;
        }
        
        .visualization-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        
        .visualization-card {
            flex: 1 1 400px;
            background-color: #0d1117;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #30363d;
        }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        select {
            background-color: #161b22;
            color: #e0e0e0;
            border: 1px solid #30363d;
            padding: 8px 12px;
            border-radius: 4px;
        }
        
        .chart-container {
            height: 300px;
            width: 100%;
            background-color: #0d1117;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }
        
        .chart-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        canvas {
            width: 100%;
            height: 100%;
        }
        
        .equation-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .equation-card {
            background-color: #0d1117;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #30363d;
        }
        
        .equation-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #58a6ff;
        }
        
        .equation {
            font-family: 'Courier New', monospace;
            padding: 10px;
            background-color: #161b22;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .equation-description {
            font-size: 0.9em;
            color: #8b949e;
        }
        
        .error-message {
            background-color: #2d0b0b;
            border: 1px solid #f85149;
            color: #f85149;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: none;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            border-top: 1px solid #30363d;
            color: #8b949e;
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="index.html" class="back-link">← Back to Main Page</a>
        <h1>HQR Mathematical Visualizations</h1>
    </div>
    
    <div class="container">
        <div class="intro">
            <p>These visualizations demonstrate the key mathematical components of Holonomic Quantum Reality (HQR) theory. Toggle between 4D and 11D representations to see how higher dimensions introduce additional complexity. Hover over elements to see detailed values and explore the relationships between different components of the theory.</p>
        </div>
        
        <div id="error-message" class="error-message">
            Unable to load interactive visualizations. Please ensure JavaScript is enabled in your browser.
        </div>
        
        <div class="visualization-section">
            <h2>Wave Function & Hidden Order</h2>
            
            <div class="controls">
                <div>
                    <label for="dimension-select">Dimension: </label>
                    <select id="dimension-select" onchange="updateDimension(this.value)">
                        <option value="4D">4D Reality</option>
                        <option value="11D">11D M-Theory</option>
                    </select>
                </div>
                <div id="dimension-display">Currently viewing: 4D Reality</div>
            </div>
            
            <div class="visualization-container">
                <div class="visualization-card">
                    <h3>Bohmian Mechanics Wave Function (Ψ = Re<sup>iS/ℏ</sup>)</h3>
                    <p>Visualizing components of the wave function and velocity field from guiding equation: dx/dt = ∇S/m</p>
                    <div class="chart-container">
                        <canvas id="wave-function-canvas"></canvas>
                    </div>
                </div>
                
                <div class="visualization-card">
                    <h3>Hidden Order Correlation</h3>
                    <p>Visualizing correlation function ⟨O(x)O(y)⟩ as a projection from higher dimensions</p>
                    <div class="chart-container">
                        <canvas id="correlation-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="visualization-section">
            <h2>Holographic Principle: AdS/CFT Correspondence</h2>
            <p>Visualizing the relationship between bulk AdS space and boundary CFT: Z<sub>CFT</sub> = ∫Dϕe<sup>-S<sub>bulk</sub>[ϕ]</sup></p>
            
            <div class="chart-container">
                <canvas id="holographic-canvas"></canvas>
            </div>
        </div>
        
        <div class="visualization-section">
            <h2>Key Equations of HQR</h2>
            
            <div class="equation-container">
                <div class="equation-card">
                    <div class="equation-title">M-Theory Metric</div>
                    <div class="equation">ds² = g<sub>μν</sub>dx<sup>μ</sup>dx<sup>ν</sup>, μ,ν = 0,1,...,10</div>
                    <div class="equation-description">Describes spacetime in 11 dimensions, where the extra dimensions are compactified at scales too small to observe directly.</div>
                </div>
                
                <div class="equation-card">
                    <div class="equation-title">Bohmian Mechanics Guiding Equation</div>
                    <div class="equation">dx/dt = ∇S/m</div>
                    <div class="equation">Where Ψ = Re<sup>iS/ℏ</sup></div>
                    <div class="equation-description">Determines particle trajectories from the wave function, providing a deterministic interpretation of quantum mechanics.</div>
                </div>
                
                <div class="equation-card">
                    <div class="equation-title">Hidden Order Correlation</div>
                    <div class="equation">⟨O(x)O(y)⟩</div>
                    <div class="equation-description">Measures subtle, long-range quantum correlations in many-body systems, potentially arising from higher-dimensional dynamics.</div>
                </div>
                
                <div class="equation-card">
                    <div class="equation-title">AdS/CFT Correspondence</div>
                    <div class="equation">Z<sub>CFT</sub> = ∫Dϕe<sup>-S<sub>bulk</sub>[ϕ]</sup></div>
                    <div class="equation-description">Links boundary conformal field theory to bulk anti-de Sitter gravity, supporting the holographic principle in HQR.</div>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        © 2025 HQR Team | <a href="index.html" style="color: #58a6ff;">Return to Main Page</a>
    </footer>
    
    <script>
        // Simple JavaScript to handle dimension toggling and basic canvas drawing
        let currentDimension = '4D';
        
        // Update dimension display and redraw visualizations
        function updateDimension(dimension) {
            currentDimension = dimension;
            document.getElementById('dimension-display').textContent = 'Currently viewing: ' + dimension;
            
            // Redraw all visualizations with the new dimension
            drawWaveFunction();
            drawCorrelation();
            drawHolographic();
        }
        
        // Draw wave function visualization
        function drawWaveFunction() {
            const canvas = document.getElementById('wave-function-canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 0.5;
            
            // Vertical grid lines
            for (let x = 0; x <= canvas.width; x += 30) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let y = 0; y <= canvas.height; y += 30) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Center axes
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.strokeStyle = '#8b949e';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            
            // Draw curves
            const complexity = currentDimension === '4D' ? 1 : 2;
            
            // Real part curve
            ctx.strokeStyle = '#8884d8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let x = 0; x < canvas.width; x++) {
                // Map canvas x to wave function domain [-10, 10]
                const xValue = (x / canvas.width) * 20 - 10;
                
                // Calculate y from real part of wave function
                const amplitude = Math.exp(-xValue*xValue / 4);
                const phase = xValue*xValue / 2 * complexity;
                const realPart = amplitude * Math.cos(phase);
                
                // Map to canvas coordinates
                const y = centerY - realPart * (canvas.height * 0.4);
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Imaginary part curve
            ctx.strokeStyle = '#82ca9d';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let x = 0; x < canvas.width; x++) {
                const xValue = (x / canvas.width) * 20 - 10;
                const amplitude = Math.exp(-xValue*xValue / 4);
                const phase = xValue*xValue / 2 * complexity;
                const imagPart = amplitude * Math.sin(phase);
                const y = centerY - imagPart * (canvas.height * 0.4);
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Hidden order correlation (dashed line)
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            
            for (let x = 0; x < canvas.width; x++) {
                const xValue = (x / canvas.width) * 20 - 10;
                const amplitude = Math.exp(-xValue*xValue / 4);
                const hiddenOrder = amplitude * Math.cos(complexity * xValue / 2) * Math.exp(-Math.abs(xValue) / 5);
                const y = centerY - hiddenOrder * (canvas.height * 0.4);
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Reset line dash
            ctx.setLineDash([]);
            
            // Legend
            const legendItems = [
                { color: '#8884d8', label: 'Real Part (Re[Ψ])' },
                { color: '#82ca9d', label: 'Imaginary Part (Im[Ψ])' },
                { color: '#ff0000', label: 'Hidden Order ⟨O(x)O(0)⟩' }
            ];
            
            ctx.font = '12px Arial';
            let legendY = 20;
            
            legendItems.forEach(item => {
                // Color box
                ctx.fillStyle = item.color;
                ctx.fillRect(10, legendY, 15, 15);
                
                // Label
                ctx.fillStyle = '#e0e0e0';
                ctx.fillText(item.label, 35, legendY + 12);
                
                legendY += 25;
            });
        }
        
        // Draw correlation visualization
        function drawCorrelation() {
            const canvas = document.getElementById('correlation-canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 0.5;
            
            // Vertical grid lines
            for (let x = 0; x <= canvas.width; x += 30) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let y = 0; y <= canvas.height; y += 30) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Center axes
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.strokeStyle = '#8b949e';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            
            // Draw correlation points
            const complexity = currentDimension === '4D' ? 1 : 2;
            const resolution = 20;
            
            for (let i = 0; i <= resolution; i++) {
                const u = (i / resolution) * Math.PI * 2;
                for (let j = 0; j <= resolution; j++) {
                    const v = (j / resolution) * Math.PI;
                    
                    // Parametric equations for projection
                    let x, y;
                    
                    if (currentDimension === '4D') {
                        x = Math.sin(u) * Math.sin(v);
                        y = Math.sin(u) * Math.cos(v);
                    } else {
                        x = Math.sin(u) * Math.sin(v) + 0.3 * Math.sin(3 * u);
                        y = Math.sin(u) * Math.cos(v) + 0.3 * Math.cos(2 * v);
                    }
                    
                    // Scale to canvas
                    x = centerX + x * (canvas.width * 0.4);
                    y = centerY - y * (canvas.height * 0.4);
                    
                    // Correlation intensity determines color
                    const correlation = Math.pow(Math.cos(complexity * u) * Math.sin(complexity * v), 2);
                    
                    // Blue color with varying intensity
                    const blue = Math.floor(150 + correlation * 105);
                    ctx.fillStyle = `rgb(50, 50, ${blue})`;
                    
                    // Draw point
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Legend
            ctx.font = '12px Arial';
            
            // Color gradient legend
            const gradientWidth = 150;
            const gradientHeight = 15;
            const gradientX = 10;
            const gradientY = 20;
            
            for (let i = 0; i < gradientWidth; i++) {
                const ratio = i / gradientWidth;
                const blue = Math.floor(150 + ratio * 105);
                ctx.fillStyle = `rgb(50, 50, ${blue})`;
                ctx.fillRect(gradientX + i, gradientY, 1, gradientHeight);
            }
            
            // Legend labels
            ctx.fillStyle = '#e0e0e0';
            ctx.fillText('Weak Correlation', gradientX, gradientY + gradientHeight + 15);
            ctx.fillText('Strong Correlation', gradientX + gradientWidth - 100, gradientY + gradientHeight + 15);
        }
        
        // Draw holographic visualization
        function drawHolographic() {
            const canvas = document.getElementById('holographic-canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Center and radius
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.4;
            
            // Draw boundary circle (CFT)
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw concentric circles (AdS bulk)
            const circles = [0.8, 0.6, 0.4, 0.2];
            
            circles.forEach((scale, idx) => {
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 1 + (1-scale) * 2;
                ctx.globalAlpha = 0.4 + ((1-scale) * 0.6);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * scale, 0, Math.PI * 2);
                ctx.stroke();
            });
            
            // Reset opacity
            ctx.globalAlpha = 1;
            
            // Draw radial lines
            const angles = [0, 45, 90, 135, 180, 225, 270, 315];
            
            angles.forEach(angle => {
                const radian = angle * Math.PI / 180;
                const x = centerX + Math.cos(radian) * radius;
                const y = centerY + Math.sin(radian) * radius;
                
                ctx.strokeStyle = '#93c5fd';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x, y);
                ctx.stroke();
            });
            
            // Reset opacity
            ctx.globalAlpha = 1;
            
            // Draw central point (deep bulk)
            ctx.fillStyle = '#1d4ed8';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw MERA tensor network for 11D
            if (currentDimension === '11D') {
                drawTensorNetwork(ctx, centerX, centerY, radius);
            }
            
            // Legend
            const legendItems = [
                { color: '#ef4444', label: 'CFT Boundary (Our 4D Reality)', type: 'line' },
                { color: '#1d4ed8', label: 'AdS Bulk (Higher Dimensions)', type: 'circle' }
            ];
            
            if (currentDimension === '11D') {
                legendItems.push({ color: '#93c5fd', label: 'MERA Tensor Network', type: 'line' });
            }
            
            ctx.font = '12px Arial';
            let legendY = 20;
            
            legendItems.forEach(item => {
                if (item.type === 'line') {
                    // Line
                    ctx.strokeStyle = item.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(10, legendY + 7);
                    ctx.lineTo(25, legendY + 7);
                    ctx.stroke();
                } else {
                    // Circle
                    ctx.fillStyle = item.color;
                    ctx.beginPath();
                    ctx.arc(17, legendY + 7, 7, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Label
                ctx.fillStyle = '#e0e0e0';
                ctx.fillText(item.label, 35, legendY + 12);
                
                legendY += 25;
            });
        }
        
        // Helper function to draw tensor network
        function drawTensorNetwork(ctx, centerX, centerY, radius) {
            ctx.globalAlpha = 0.4;
            
            // Define levels of the network
            const levels = [0, 1, 2, 3];
            
            // Draw nodes at each level
            levels.forEach(level => {
                const levelRadius = (level === 0) ? 10 : radius * (0.2 + level * 0.2);
                const nodesAtLevel = 4 + level * 2;
                
                for (let i = 0; i < nodesAtLevel; i++) {
                    const angle = (i / nodesAtLevel) * Math.PI * 2;
                    const x = centerX + levelRadius * Math.cos(angle);
                    const y = centerY + levelRadius * Math.sin(angle);
                    
                    // Node color based on level
                    if (level === 0) {
                        ctx.fillStyle = '#1d4ed8';
                    } else if (level === 3) {
                        ctx.fillStyle = '#ef4444';
                    } else {
                        ctx.fillStyle = '#3b82f6';
                    }
                    
                    // Draw node
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw connections between adjacent levels
            for (let level = 0; level < 3; level++) {
                const innerRadius = (level === 0) ? 10 : radius * (0.2 + level * 0.2);
                const outerRadius = radius * (0.2 + (level + 1) * 0.2);
                const innerNodes = 4 + level * 2;
                const outerNodes = 4 + (level + 1) * 2;
                
                for (let i = 0; i < innerNodes; i++) {
                    const innerAngle = (i / innerNodes) * Math.PI * 2;
                    const x1 = centerX + innerRadius * Math.cos(innerAngle);
                    const y1 = centerY + innerRadius * Math.sin(innerAngle);
                    
                    // Connect each inner node to two outer nodes
                    for (let j of [i*2, i*2+1]) {
                        if (j < outerNodes) {
                            const outerAngle = (j / outerNodes) * Math.PI * 2;
                            const x2 = centerX + outerRadius * Math.cos(outerAngle);
                            const y2 = centerY + outerRadius * Math.sin(outerAngle);
                            
                            // Connection color
                            ctx.strokeStyle = (level === 2) ? '#fca5a5' : '#93c5fd';
                            ctx.lineWidth = 1;
                            
                            // Draw connection
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // Reset opacity
            ctx.globalAlpha = 1;
        }
        
        // Initialize visualizations
        function initVisualizations() {
            try {
                drawWaveFunction();
                drawCorrelation();
                drawHolographic();
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    drawWaveFunction();
                    drawCorrelation();
                    drawHolographic();
                });
                
                // Hide error message if successful
                document.getElementById('error-message').style.display = 'none';
            } catch (error) {
                console.error('Visualization error:', error);
                document.getElementById('error-message').style.display = 'block';
            }
        }
        
        // Call initialization when DOM is loaded
        document.addEventListener('DOMContentLoaded', initVisualizations);
    </script>
</body>
</html>
