<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HQR Simplified Visualizations</title>
    <link rel="stylesheet" href="visualization.css">
    <!-- Required libraries for React visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/17.0.2/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.2/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.1.9/Recharts.js"></script>

    <!-- Correct paths for root directory -->
    <script src="visualization.js"></script>
    <!-- Load HQR visualization JS only once -->
    <script src="hqr-visualization.js"></script>
    
    <!-- Custom stylesheets -->
    <link rel="stylesheet" href="visualization.css">
    
    <!-- Base styles that should remain in HTML -->
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0; /* Fixed from La0 to 0 */
            padding: 0;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        
        .header {
            padding: 20px;
            background-color: #0d1117;
            border-bottom: 1px solid #30363d;
        }
        
        .back-link {
            color: #58a6ff;
            text-decoration: none;
            display: inline-block;
            margin-bottom: 10px;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .intro {
            margin-bottom: 30px;
            line-height: 1.6;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            border-top: 1px solid #30363d;
            color: #8b949e;
        }
        
        /* Pre-animation styles for transitions */
        .visualization-section {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        
        .visualization-section.loaded {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Loading indicator */
        .loading-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #58a6ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Error state styling */
        .error-state {
            background-color: #2d0b0b;
            border: 1px solid #f85149;
            color: #f85149;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        /* Error message styling */
        .error-message {
            background-color: #2d0b0b;
            border: 1px solid #f85149;
            color: #f85149;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: block; /* Make sure it's visible initially */
        }
        
        /* Chart container sizing */
        .chart-container {
            min-height: 300px;
            width: 100%;
            position: relative;
        }
    </style>
</head>
<body class="dark-theme">
    <div class="header">
        <a href="index.html" class="back-link">← Back to Main Page</a>
        <h1>HQR Mathematical Visualizations</h1>
    </div>
    
    <div class="container">
        <div class="intro">
            <p>These visualizations demonstrate the key mathematical components of Holonomic Quantum Reality (HQR) theory. Toggle between 4D and 11D representations to see how higher dimensions introduce additional complexity. Hover over elements to see detailed values and explore the relationships between different components of the theory.</p>
        </div>
        
        <div id="error-message" class="error-message">
            Unable to load interactive visualizations. Please ensure JavaScript is enabled in your browser.
        </div>
        
        <div class="visualization-section" data-animation-delay="100">
            <h2>Wave Function & Hidden Order</h2>
            
            <div class="controls">
                <div>
                    <label for="dimension-select">Choose Dimension: </label>
                    <select id="dimension-select" onchange="updateDimension(this.value)">
                        <option value="4D">4D Reality</option>
                        <option value="11D">11D M-Theory</option>
                    </select>
                </div>
                <div id="dimension-display">Currently viewing: 4D Reality</div>
            </div>
            
            <div class="visualization-container">
                <div class="visualization-card">
                    <h3>Bohmian Mechanics Wave Function (Ψ = Re<sup>iS/ℏ</sup>)</h3>
                    <p>Visualizing components of the wave function and velocity field from guiding equation: dx/dt = ∇S/m</p>
                    <div class="chart-container">
                        <canvas id="wave-function-canvas"></canvas>
                    </div>
                </div>
                
                <div class="visualization-card">
                    <h3>Hidden Order Correlation</h3>
                    <p>Visualizing correlation function ⟨O(x)O(y)⟩ as a projection from higher dimensions</p>
                    <div class="chart-container">
                        <canvas id="correlation-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="visualization-section" data-animation-delay="200">
            <h2>Holographic Principle: AdS/CFT Correspondence</h2>
            <p>Visualizing the relationship between bulk AdS space and boundary CFT: Z<sub>CFT</sub> = ∫Dϕe<sup>-S<sub>bulk</sub>[ϕ]</sup></p>
            
            <div class="chart-container">
                <canvas id="holographic-canvas"></canvas>
            </div>
        </div>
        
        <div class="visualization-section" data-animation-delay="300">
            <h2>Key Equations of HQR</h2>
            
            <div class="equation-container">
                <div class="equation-card">
                    <div class="equation-title">M-Theory Metric</div>
                    <div class="equation">ds² = g<sub>μν</sub>dx<sup>μ</sup>dx<sup>ν</sup>, μ,ν = 0,1,...,10</div>
                    <div class="equation-description">Describes spacetime in 11 dimensions, where the extra dimensions are compactified at scales too small to observe directly.</div>
                </div>
                
                <div class="equation-card">
                    <div class="equation-title">Bohmian Mechanics Guiding Equation</div>
                    <div class="equation">dx/dt = ∇S/m</div>
                    <div class="equation">Where Ψ = Re<sup>iS/ℏ</sup></div>
                    <div class="equation-description">Determines particle trajectories from the wave function, providing a deterministic interpretation of quantum mechanics.</div>
                </div>
                
                <div class="equation-card">
                    <div class="equation-title">Hidden Order Correlation</div>
                    <div class="equation">⟨O(x)O(y)⟩</div>
                    <div class="equation-description">Measures subtle, long-range quantum correlations in many-body systems, potentially arising from higher-dimensional dynamics.</div>
                </div>
                
                <div class="equation-card">
                    <div class="equation-title">AdS/CFT Correspondence</div>
                    <div class="equation">Z<sub>CFT</sub> = ∫Dϕe<sup>-S<sub>bulk</sub>[ϕ]</sup></div>
                    <div class="equation-description">Links boundary conformal field theory to bulk anti-de Sitter gravity, supporting the holographic principle in HQR.</div>
                </div>
            </div>
        </div>
        
        <!-- React-based Hidden Order Parameter Visualization -->
        <div class="visualization-section" data-animation-delay="400">
            <h2>Hidden Order Parameter Analysis</h2>
            <p>Interactive visualization of hidden order parameters, entropy components, and phase transitions in quantum systems.</p>
            
            <!-- React component will be mounted here -->
            <div id="hidden-order-visualization-root">
                <div class="loading-spinner">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
        
        <!-- New advanced visualization section for HQR -->
        <div class="visualization-section" data-animation-delay="500">
            <h2>Advanced HQR Dynamic Visualizations</h2>
            <p>Interactive physics models demonstrating the core principles of Holonomic Quantum Reality theory with real-time parameter adjustments.</p>
            
            <!-- HQR React component will be mounted here -->
            <div id="hqr-visualization-root">
                <div class="loading-spinner">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        © 2025 HQR Team | <a href="index.html" style="color: #58a6ff;">Return to Main Page</a>
    </footer>
    
    <!-- Load regular canvas-based visualizations -->
    <script>
        // Simple JavaScript to handle dimension toggling and basic canvas drawing
        let currentDimension = '4D';
        
        // Update dimension display and redraw visualizations
        function updateDimension(dimension) {
            currentDimension = dimension;
            document.getElementById('dimension-display').textContent = 'Currently viewing: ' + dimension;
            
            // Redraw all visualizations with the new dimension
            drawWaveFunction();
            drawCorrelation();
            drawHolographic();
        }
        
        // Draw wave function visualization
        function drawWaveFunction() {
            const canvas = document.getElementById('wave-function-canvas');
            if (!canvas) {
                console.error('Canvas element wave-function-canvas not found');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get 2D context for wave-function-canvas');
                return;
            }
            
            // Set canvas dimensions correctly - this is crucial
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 0.5;
            
            // Vertical grid lines
            for (let x = 0; x <= canvas.width; x += 30) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let y = 0; y <= canvas.height; y += 30) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Center axes
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.strokeStyle = '#8b949e';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            
            // Draw curves
            const complexity = currentDimension === '4D' ? 1 : 2;
            
            // Real part curve
            ctx.strokeStyle = '#8884d8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let x = 0; x < canvas.width; x++) {
                // Map canvas x to wave function domain [-10, 10]
                const xValue = (x / canvas.width) * 20 - 10;
                
                // Calculate y from real part of wave function
                const amplitude = Math.exp(-xValue*xValue / 4);
                const phase = xValue*xValue / 2 * complexity;
                const realPart = amplitude * Math.cos(phase);
                
                // Map to canvas coordinates
                const y = centerY - realPart * (canvas.height * 0.4);
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Imaginary part curve
            ctx.strokeStyle = '#82ca9d';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let x = 0; x < canvas.width; x++) {
                const xValue = (x / canvas.width) * 20 - 10;
                const amplitude = Math.exp(-xValue*xValue / 4);
                const phase = xValue*xValue / 2 * complexity;
                const imagPart = amplitude * Math.sin(phase);
                const y = centerY - imagPart * (canvas.height * 0.4);
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Hidden order correlation (dashed line)
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            
            for (let x = 0; x < canvas.width; x++) {
                const xValue = (x / canvas.width) * 20 - 10;
                const amplitude = Math.exp(-xValue*xValue / 4);
                const hiddenOrder = amplitude * Math.cos(complexity * xValue / 2) * Math.exp(-Math.abs(xValue) / 5);
                const y = centerY - hiddenOrder * (canvas.height * 0.4);
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Reset line dash
            ctx.setLineDash([]);
            
            // Legend
            const legendItems = [
                { color: '#8884d8', label: 'Real Part (Re[Ψ])' },
                { color: '#82ca9d', label: 'Imaginary Part (Im[Ψ])' },
                { color: '#ff0000', label: 'Hidden Order ⟨O(x)O(0)⟩' }
            ];
            
            ctx.font = '12px Arial';
            let legendY = 20;
            
            legendItems.forEach(item => {
                // Color box
                ctx.fillStyle = item.color;
                ctx.fillRect(10, legendY, 15, 15);
                
                // Label
                ctx.fillStyle = '#e0e0e0';
                ctx.fillText(item.label, 35, legendY + 12);
                
                legendY += 25;
            });
        }
        
        // Draw correlation visualization
        function drawCorrelation() {
            const canvas = document.getElementById('correlation-canvas');
            if (!canvas) {
                console.error('Canvas element correlation-canvas not found');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get 2D context for correlation-canvas');
                return;
            }
            
            // Set canvas dimensions correctly
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 0.5;
            
            // Vertical grid lines
            for (let x = 0; x <= canvas.width; x += 30) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let y = 0; y <= canvas.height; y += 30) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Center axes
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.strokeStyle = '#8b949e';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            
            // Draw correlation points
            const complexity = currentDimension === '4D' ? 1 : 2;
            const resolution = 20;
            
            for (let i = 0; i <= resolution; i++) {
                const u = (i / resolution) * Math.PI * 2;
                for (let j = 0; j <= resolution; j++) {
                    const v = (j / resolution) * Math.PI;
                    
                    // Parametric equations for projection
                    let x, y;
                    
                    if (currentDimension === '4D') {
                        x = Math.sin(u) * Math.sin(v);
                        y = Math.sin(u) * Math.cos(v);
                    } else {
                        x = Math.sin(u) * Math.sin(v) + 0.3 * Math.sin(3 * u);
                        y = Math.sin(u) * Math.cos(v) + 0.3 * Math.cos(2 * v);
                    }
                    
                    // Scale to canvas
                    x = centerX + x * (canvas.width * 0.4);
                    y = centerY - y * (canvas.height * 0.4);
                    
                    // Correlation intensity determines color
                    const correlation = Math.pow(Math.cos(complexity * u) * Math.sin(complexity * v), 2);
                    
                    // Blue color with varying intensity
                    const blue = Math.floor(150 + correlation * 105);
                    ctx.fillStyle = `rgb(50, 50, ${blue})`;
                    
                    // Draw point
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Legend
            ctx.font = '12px Arial';
            
            // Color gradient legend
            const gradientWidth = 150;
            const gradientHeight = 15;
            const gradientX = 10;
            const gradientY = 20;
            
            for (let i = 0; i < gradientWidth; i++) {
                const ratio = i / gradientWidth;
                const blue = Math.floor(150 + ratio * 105);
                ctx.fillStyle = `rgb(50, 50, ${blue})`;
                ctx.fillRect(gradientX + i, gradientY, 1, gradientHeight);
            }
            
            // Legend labels
            ctx.fillStyle = '#e0e0e0';
            ctx.fillText('Weak', gradientX, gradientY + gradientHeight + 15);
            ctx.fillText('Strong', gradientX + gradientWidth - 50, gradientY + gradientHeight + 15);
        }
        
        // Draw holographic visualization
        function drawHolographic() {
            const canvas = document.getElementById('holographic-canvas');
            if (!canvas) {
                console.error('Canvas element holographic-canvas not found');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get 2D context for holographic-canvas');
                return;
            }
            
            // Set canvas dimensions correctly
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Center and radius
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.4;
            
            // Draw boundary circle (CFT)
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw concentric circles (AdS bulk)
            const circles = [0.8, 0.6, 0.4, 0.2];
            
            circles.forEach((scale, idx) => {
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 1 + (1-scale) * 2;
                ctx.globalAlpha = 0.4 + ((1-scale) * 0.6);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * scale, 0, Math.PI * 2);
                ctx.stroke();
            });
            
            // Reset opacity
            ctx.globalAlpha = 1;
            
            // Draw radial lines
            const angles = [0, 45, 90, 135, 180, 225, 270, 315];
            
            angles.forEach(angle => {
                const radian = angle * Math.PI / 180;
                const x = centerX + Math.cos(radian) * radius;
                const y = centerY + Math.sin(radian) * radius;
                
                ctx.strokeStyle = '#93c5fd';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x, y);
                ctx.stroke();
            });
            
            // Reset opacity
            ctx.globalAlpha = 1;
            
            // Draw central point (deep bulk)
            ctx.fillStyle = '#1d4ed8';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw MERA tensor network for 11D
            if (currentDimension === '11D') {
                drawTensorNetwork(ctx, centerX, centerY, radius);
            }
            
            // Legend
            const legendItems = [
                { color: '#ef4444', label: 'CFT Boundary (Our 4D Reality)', type: 'line' },
                { color: '#1d4ed8', label: 'AdS Bulk (Higher Dimensions)', type: 'circle' }
            ];
            
            if (currentDimension === '11D') {
                legendItems.push({ color: '#93c5fd', label: 'MERA Tensor Network', type: 'line' });
            }
            
            ctx.font = '12px Arial';
            let legendY = 20;
            
            legendItems.forEach(item => {
                if (item.type === 'line') {
                    // Line
                    ctx.strokeStyle = item.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(10, legendY + 7);
                    ctx.lineTo(25, legendY + 7);
                    ctx.stroke();
                } else {
                    // Circle
                    ctx.fillStyle = item.color;
                    ctx.beginPath();
                    ctx.arc(17, legendY + 7, 7, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Label
                ctx.fillStyle = '#e0e0e0';
                ctx.fillText(item.label, 35, legendY + 12);
                
                legendY += 25;
            });
        }
        
        // Helper function to draw tensor network
        function drawTensorNetwork(ctx, centerX, centerY, radius) {
            ctx.globalAlpha = 0.4;
            
            // Define levels of the network
            const levels = [0, 1, 2, 3];
            
            // Draw nodes at each level
            levels.forEach(level => {
                const levelRadius = (level === 0) ? 10 : radius * (0.2 + level * 0.2);
                const nodesAtLevel = 4 + level * 2;
                
                for (let i = 0; i < nodesAtLevel; i++) {
                    const angle = (i / nodesAtLevel) * Math.PI * 2;
                    const x = centerX + levelRadius * Math.cos(angle);
                    const y = centerY + levelRadius * Math.sin(angle);
                    
                    // Node color based on level
                    if (level === 0) {
                        ctx.fillStyle = '#1d4ed8';
                    } else if (level === 3) {
                        ctx.fillStyle = '#ef4444';
                    } else {
                        ctx.fillStyle = '#3b82f6';
                    }
                    
                    // Draw node
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw connections between adjacent levels
            for (let level = 0; level < 3; level++) {
                const innerRadius = (level === 0) ? 10 : radius * (0.2 + level * 0.2);
                const outerRadius = radius * (0.2 + (level + 1) * 0.2);
                const innerNodes = 4 + level * 2;
                const outerNodes = 4 + (level + 1) * 2;
                
                for (let i = 0; i < innerNodes; i++) {
                    const innerAngle = (i / innerNodes) * Math.PI * 2;
                    const x1 = centerX + innerRadius * Math.cos(innerAngle);
                    const y1 = centerY + innerRadius * Math.sin(innerAngle);
                    
                    // Connect each inner node to two outer nodes
                    for (let j of [i*2, i*2+1]) {
                        j = j % outerNodes; // Ensure we don't go out of bounds
                        const outerAngle = (j / outerNodes) * Math.PI * 2;
                        const x2 = centerX + outerRadius * Math.cos(outerAngle);
                        const y2 = centerY + outerRadius * Math.sin(outerAngle);
                        
                        // Connection color
                        ctx.strokeStyle = (level === 2) ? '#fca5a5' : '#93c5fd';
                        ctx.lineWidth = 1;
                        
                        // Draw connection
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
            }
            
            // Reset opacity
            ctx.globalAlpha = 1;
        }
        
        // Initialize visualizations
        function initVisualizations() {
            try {
                console.log("Initializing canvas visualizations...");
                
                // Check if canvas elements exist
                const waveFunctionCanvas = document.getElementById('wave-function-canvas');
                const correlationCanvas = document.getElementById('correlation-canvas');
                const holographicCanvas = document.getElementById('holographic-canvas');
                
                if (!waveFunctionCanvas) console.error("wave-function-canvas not found");
                if (!correlationCanvas) console.error("correlation-canvas not found");
                if (!holographicCanvas) console.error("holographic-canvas not found");
                
                // Force a minimum size for the chart containers
                document.querySelectorAll('.chart-container').forEach(container => {
                    if (container.clientHeight < 300) {
                        container.style.height = "300px";
                    }
                });
                
                // Now draw the visualizations
                drawWaveFunction();
                drawCorrelation();
                drawHolographic();
                
                // Handle window resize with debounce
                let resizeTimeout;
                window.addEventListener('resize', function() {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(function() {
                        console.log("Window resized, redrawing visualizations...");
                        drawWaveFunction();
                        drawCorrelation();
                        drawHolographic();
                    }, 250);
                });
                
                // Animate in sections
                animateSections();
                
                // Hide error message if successful
                document.getElementById('error-message').style.display = 'none';
            } catch (error) {
                console.error('Visualization error:', error);
                document.getElementById('error-message').style.display = 'block';
                document.getElementById('error-message').textContent = 'Error initializing visualizations: ' + error.message;
            }
        }
        
        // Animation for sections
        function animateSections() {
            const sections = document.querySelectorAll('.visualization-section');
            
            sections.forEach(section => {
                const delay = parseInt(section.getAttribute('data-animation-delay')) || 0;
                
                setTimeout(() => {
                    section.classList.add('loaded');
                }, delay);
            });
        }
        
        // Call initialization when DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initVisualizations);
        } else {
            // DOM already loaded, initialize immediately
            initVisualizations();
        }
        
        // Fallback timer in case the DOMContentLoaded event already fired or doesn't trigger properly
        setTimeout(function() {
            console.log("Fallback timer triggered for initialization");
            initVisualizations();
        }, 500);
